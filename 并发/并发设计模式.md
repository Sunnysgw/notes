常用设计模式类别

- 线程终止的模式

  直接用stop的方式停止线程，会导致获取的锁直接被释放

  可以调用线程的interrupt方法告诉线程，它要中断了，执行任务的线程中可以定期轮询是否已经是中断状态，检测到自己是中断状态之后，就可以执行对应的停止指令。同时，线程中调用sleep wait这些方法被打断之后抛出InterruptException异常之后，会清除中断标识位的，所以要在catch到这种异常之后，重新设置中断标识位。是如下这种模式：

  ```java
  public void work() {
      while (!Thread.currentThread().isInterrupted()) {
          try {
              TimeUnit.SECONDS.sleep(3);
          } catch (InterruptedException e) {
              Thread.currentThread().interrupt();
          }
      }
      stop();
  }
  ```

  所以，如果一旦没有正常处理这种异常，就会有bug。可以利用volatile关键字修饰的flag来实现这种功能。

- 保证线程安全的模式

  **使用不可变对象**

  初始化之后就是不可变的，保证线程安全，例如string integer等都是不可变类。

  **copyonwrite**

  copyonwrite模式，对于有修改的操作，就直接copy一份副本，之后在副本上做修改，修改完成之后，用新生成的副本替代原有的内容，对于多个修改的操作方法，需要加同一把锁。这种模式对读多写少的场景比较友好。看了下jdk11中，把锁从reentrantlock换成了sync。

  **线程独占**

  如果变量是线程独有的，那么就自然可以保证线程安全，有两种方式：

  - 尽量使用局部变量
  - 对于要穿插在线程的整个执行过程中的变量，threadlocal是一种选择，线程池中添加到threadlocal中尤其记得要及时remove掉存进去的数据，防止内存泄漏以及线程安全问题。

- 多线程协作的模式

  等待唤醒机制

- 独占模式

  cas竞争修改变量

  单例模式二次校验

  基于锁加上标志位的单次执行模式

- 线程间传递消息的模式

  生产者消费者模式，核心就是阻塞队列。



获取sync锁，执行代码之前，要把保存的缓存副本清空，所有的都从主内存中重新读取，释放锁之前，要保证所有在工作内存中做的修改已经写入到主内存中。这样，只要是在sync代码块中执行的语句，就一定能保证其中变量的可见性。

但是double check中的场景，是因为两个线程一个是获取锁，另一个是在锁外执行的，所以就导致锁外的线程读取到的变量的值可能是因为指令重排序的原因导致变量没有经过初始化。

所以volatile关键字是为了保护那些没有在锁中的变量的可见性。