# CAS算法

> 应用场景，多线程自增，或者极端场景优化性能时候，可以考虑使用cas来做锁。

cas是juc下比较常用的操作，全称（compare and swap，比较并交换），属于乐观锁的概念

可见性是基于lock前缀指令来做的。

> 不管是jvm中的Atomic::cmpxchg还是java中unsafe中的cas方法，都是对相应平台中cas指令的简单封装，cas指令作为一种硬件原语，有着天然的原子性，这也正是cas的价值所在。

cas只是一个指令，不涉及cpu用户态到内核态的操作，相对于sycn关键字，能提升效率。

**缺点：**

但是如果竞争激烈，因为中间存在自旋操作，浪费cpu性能，

只能保证一个对象的原子性，

会有aba的问题：对于cas中的c，如果只是比较对应的值，那么可能会对值的等价修改（对于a，改成b，之后又改回a）不敏感。



cas操作过程中存在大量的自旋操作，浪费时间

**改进**

可以考虑借鉴map reduce的操作，把大的累加分割成多个小的。这里就是LongAdder DoubleAdder

> cas锁，即构造一个状态量，之后多个线程使用cas竞争修改状态量，这样就保证只有一个线程取到锁。

基于cas构造一个锁，这个锁保证累加过程中的线程安全。LongAdder中有一个base和一个cell数组，要做cas操作的时候，给线程提供了base以及cell数组多种选择，加的时候优先加base，如果失败了，就基于hash找到对应的cell再做cas。

累加是安全的，但是sum不是安全的，取sum的时候没有做线程安全的保证，就是直接加。



