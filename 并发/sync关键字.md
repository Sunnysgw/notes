# synchronized

临界区

一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为**临界区**，其共享资源为**临界资源**



是基于Monitor机制实现，依赖操作系统底层的Mutex互斥原语。操作系统层面叫管程，是指管理共享变量以及对共享变量操作的过程。



jvm大体上是基于MESI模型管理线程的，是非公平锁，如下：

![image-20220817112704076](E:\Document\work\笔记\image-20220817112704076.png)

这里cxq是栈的结构，后进先出，所以宏观情况下，最先申请锁的线程，反而可能是最后才能拿到锁。这里entrylist是一个队列的结构，基本思路是如果entrylist为空，则cxq中的线程出栈，进入entrylist队列，之后取entrylist队列首的线程，获取锁。如果entrylist不为空，则直接取头部的线程获取锁。



1.8中对sync的机制进行了升级，不是所有的情况都会进重量级锁。



> 对象内存布局
>
> new Object()在内存中占几个字节 
>
> mark world -> 存储对象运行时自身的数据：hashcode gcage 持有锁  锁状态标志位 偏向线程id 偏向持剑戳 8B
>
> class mark -> 指向元数据区域中该对象的类信息 4B
>
> 数组长度 (只有数组才会有) 4B
>
> 同时，一个对象占据的空间要是8的整数倍
>
> 所以对于一个new Object()对象，根据杉树分析一共是12个字节，之后填充成8的整数倍，即16个字节。

**锁有以下几种状态**

无锁

偏向锁：偏向锁是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多 线程竞争，而且总是由同一线程多次获得，因此为了消除数据在无竞争情况下锁重入（CAS操 作）的开销而引入偏向锁。对于没有锁竞争的场合，偏向锁有很好的优化效果。

轻量级锁 倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的 优化手段，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁所适应的场景是线程交替执 行同步块的场合，如果存在同一时间多个线程访问同一把锁的场合，就会导致轻量级锁膨胀为重 量级锁。

重量级锁 指向monitor的地址



> 轻量级锁和偏向锁的信息都是存放在对象头的mark work中了，这些都是直接在用户态能够操作的，但是重量级锁的信息处理是要切换到内核态来处理的。

获取轻量级锁







jvm模式是延迟偏向的，即启动的4s之后，新生成的对象才会被标记为偏向锁（对应thread为0，即为可获取），其他情况下新生成的对象是无锁状态。

当是偏向锁的时候，mark world没有地方存取hashcode，所以如果是在偏向锁的状态调用对象的hashcode方法：

可获取的状态（threadid 为0）：转化成无锁

已经绑定thread：转化为重量锁

偏向锁状态下，调用notify，会转化成轻量锁，调用wait，会转化成重量锁



轻量锁、重量锁的判定是基于竞争是否激烈来决定的。



偏向锁解锁之后，还是偏向锁。

无锁状态不太会变成偏向锁的状态。

竞争稍微激烈，偏向锁撤销，转化成轻量锁。

![锁升级流程图](E:\Document\work\笔记\锁升级流程图.png)



## sync的优化

- 偏向锁批量偏向/撤销

- 重量锁自旋

  使用cas的操作，加自旋，尝试获取锁，防止切换到内核态

- 锁消除

  编译器发现不需要锁的情况，或者锁不会起作用，就会消除不太需要的锁

- 锁粗化

  发现连续获取锁的情况，可能会把加锁的力度放大

  
