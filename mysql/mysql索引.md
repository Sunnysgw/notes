# mysql 优化

## 1. 索引数据结构

> 索引是帮助MySQL高效获取数据的一种<排好序>的数据结构。`

如果不加索引，查询数据的过程需要逐行扫描，如果表中数据较多，就需要大量的磁盘io操作，而io操作是比较耗费性能的。索引的使命就是要通过预先存储一些地址信息，减少查询次数。

索引的几种候选的数据结构

- 二叉搜索树

  保证对于任意节点，左节点小于等于节点，右节点大于等于节点，可以用来存储mysql的索引，但是可能会退化成链表，不能保证查询效率

- 红黑树

  可以有效控制二叉搜索树的高度平衡，防止二叉树退化。但是，这样一层存储的内容还是有点少，表的容量上来了，树的高度也上来了，不太巧的话，查找过程中需要每层都走一遍，io还是高了

- b树

  针对红黑树每个节点容量比较小的问题，有了b树，如下

  ![image-20220928090224608](/Users/sunny/Documents/notes/image-20220928090224608.png)

- b+树

  针对b树做了一些优化

  ![image-20220928090303172](/Users/sunny/Documents/notes/image-20220928090303172.png)

  非叶子节点不存数据，叶子节点包含了所有的索引元素，**叶子节点使用指针连接，提高了区间访问的性能**。同时因为非叶子节点不存数据，所以可以存更多的地址，树的高度也就越小。

  一个非叶子节点大小为16kb，是磁盘一个卷的大小，读取一个节点需要一次io。

  
  
  一次查询过程？增加索引的过程？

- hash索引

  使用类似hash的方式存放每一行数据，使用方式类似于hashmap，单个查询效率更高，但是范围查询效率不会很高。

目前大多数用innodb引擎，引擎是在表级别生效的。存储引擎

- myisam引擎

  索引和数据是分离的？索引使用b+树的结构，属于**非聚集索引**

  查询的时候，即从根节点开始找，之后逐层向下，直到叶子结点，找到叶子结点中记录的对应行的地址，之后从数据文件中取对应数据。

- innodb引擎

  索引和数据是放一起的，即叶子节点存放的是其他列的数据，属于**聚集索引**
  
  不同于myisam引擎，innodb叶子结点存放的是索引所在行的其他列的数据。
  
  只有一个**聚集索引**，即使用**主键构建的索引**，对于其他的索引，同样用之来构建b+树，但是叶子结点不会存其他列的数据，存对应行的**主键**，后面查询的时候基于给的主键去查询数据，这个过程是**回表**。

**聚集和非聚集这两种索引的优劣？**

聚集索引查询效率要高一些，因为不涉及二次查找。

**为什么建议innodb表建主键，并推荐使用整型的自增主键？**

innodb引擎的表中，默认基于b+树的结构存储，如果没有主键，则去找一个具有唯一性的列作为键构建b+树。

b+树的查找过程，涉及逐层比较大小的过程，整型比较大小效率更高。同时整型占用空间较小，这样b+树每个节点就可以存放更多元素。

自增主键？逐步递增的索引对构建存储数据的b+树更友好。

-------

以下讲的步骤基本基于innodb来做的

**联合索引**

基于索引中的所有字段排序，按照声明索引的字典序列排序，解决了这个问题，那么聚合索引就跟单一的索引插入方式一致了。

联合索引查询过程按照**最左前缀**来的。具体来的话，就是联合索引给索引排序是按照字典序来的，也就保证只有从联合索引最前面的列开始，才能保证一定顺序。更具体来说，比如构建了a b c这三个列的的索引，只能保证a、a b、a b c才是能排序的，否则b+树这种结构就不能用了。

## 2. 索引优化

> mysql join表格，有：
>
> join 语义即遍历左侧表，执行条件语句，如右侧表中有满足条件的数据，即拼接成新的行，查出来几行就拼几行
>
> left join 基本同join，如果右侧表中没有满足条件的数据，也会拼接生成新的行，不过右侧数据部分是空
>
> right join 和leftjoin相反，以右侧表为主

### 2.1 explain工具

用于分析其后的sql执行情况

- id

  查询的id，值越大，执行越靠前

- select type

  查询的类型

  - 对于没有嵌套查询的sql，直接是simple
  - 对于有嵌套关系的查询，最外面的类型是primary，是最后执行的查询
  - from前的子查询是subquery
  - from后的子查询是drived，可以理解成是由查询语句生成的临时表，需要转存一下，供之后从中取结果，primary查询依赖其查询的结果

- table

  查询的表

- type

  - null

    sql解析的时候直接就优化了，已经得到了结果

  - system

    查询表中只有一条记录

  - const

    基于primary key或者unique key全部列通常数比较，只要在b+数中查询一次，之后只要查询结果。

  - eq_ref

    primary key或者unique key索引的所有列被链接使用，即使用多个唯一索引依次查询

  - ref

    使用了不唯一的索引或者唯一索引的部分前缀做了查询，这样一次可以查出来多个

  - range

    使用索引做范围查询，包含in between，> < >=等操作

  - index

    扫描所有索引得到结果，即看查询的字段是否能被某个索引覆盖，优先使用二级索引，因为二级索引不会存所有数据，占用空间会小

  - all

    全表扫描，即扫描聚合索引的所有叶子结点

  index、all这种要做优化的。

- possible_keys

  可能会使用的key

- key

  查询的时候真正使用的索引

- key_len

  用到的索引的字节数，可以用它来确定联合索引用到了哪几位

- ref

  查询的时候，索引要比对的值

- rows

  预估要查询的行数

- extra

  展示额外信息

  - Using index

    查询二级索引的时候，查询的结果集中的列，被索引包含了，不需要再回表了。

### 2.2 索引最佳实践

**最左匹配原则**，对于最左匹配原则，即从索引的最左侧开始，看该列是否在查询条件中存在且条件为=、like 确定的值%，如存在则继续找索引中的下一列，如为>或者<这种范围查询，即停止搜索，索引使用到这一步就结束了。有点意思的是，**在使用like匹配前缀的搜索中，是可以继续处理下一个索引的**，这个东西明明语义上是范围查询，却能被当作定植处理，是真的想不通的，要理解这个，是要明白符合索引树是怎么做搜索的，如果查询的条件完全覆盖了索引列，搜索过程就和单一列的索引树一致。

最好查询条件能够尽可能多的落在索引上，基于最左匹配原则来判断。



**最佳实践**：

- 不要在索引上做操作，因为索引树上的值并没有做对应操作
- 尽量使用覆盖索引，即查询列在索引树中，避免回表操作
- 基于索引树的结构，不等于、不存在这些操作基本用不到索引
- mysql会对范围索引做评估，如果范围索引单次查询范围较大，可能不会走索引。

我自己的理解，索引本质上就是空间换时间的操作，换的时间是查询时间，对更新时间来讲，索引越多，越复杂，耗费时间会越久，因为可能会涉及同步修改二级索引树，对于innodb中，默认都会有一个primary索引树，是聚合索引，叶子结点放的是其它列的数据，二级索引树的叶子结点放的则是该行对应的primary key值，要得到所有数据还需要再次查询primary 索引树。所以索引并不是越多越好，一般会有一个经验值吧todo。

## 3. mysql执行过程

**大体构成**

- 客户端

  客户端服务端建立连接，会建立一个会话，其中存放登录时用户的权限。

- server

- 引擎

  插拔的方式来做的，innodb、myisam等，是针对
