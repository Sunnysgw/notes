# redis

## 1. 常用数据结构

### 1.1 string

常用命令 

- set 

- get 

  spring session就是利用redis的string来存的

- del 

- setnx 

  分布式锁使用的命令

- mset 

- mget

- incr

  原子性+1，类似于juc的atomic机制

  场景：

  统计阅读量

  批量生成序列号

- decr

  原子性-1

通用增删改查

过期时间设置：setex

原子性设置：setnx，如存在即设置失败

原子性加减：incr、decr、incrby、decrby

批量设置 mset mget

bit相关操作

### 1.2 hash

常用命令

- 增删改查

  hset

  hsetnx 同string中的操作，如存在返回0，不存在设置并返回1

  hdel 删除某个hash中的key值

  Hget

  hmget

  hkeys 得到所有field

  hvals 返回所有value

  hexists 查看是否存在某个field

  Hrandfield 随机返回一个hash中的field，参数可以控制返回几个field，是否返回对应的value

  hincrby 某个field加给定值

  hincrbyfloat 某个field加给定小数

  hscan 类似scan的方式查找hash中的field，使用方式是hscan key cursor match pattern count n，这里cursor和存放数据的slot有一定关系todo

  

是一个 key -> value 的结构，其中value同样是key-value的结构

不同于string，hash的value也是一系列key-value的对，对于其中value的操作类似于string的操作，同样可以做原子加减

**场景**

对象缓存，存放对象的不同字段，如果key比较大，redis会比较麻烦

**优点**

相对string ，数据管理更紧凑，存储空间、性能方面更优

**缺点**

过期功能只能用到key中，不能用到field中

集群架构下不适合大规模使用？

### 1.3 列表list

**常用操作**

lpush

rpush

lpop

rpop

blpop

brpop

Lmove 在两个list之间移动元素

linsert 向list中指定位置插入元素

llen 长度

lpushx 只有当list存在才添加元素

lrem 删除一定数量的元素

ltrim 截取list

使用这些基本命令可以实现队列、栈以及阻塞队列、阻塞栈的形式。

常用的场景，例如消息队列

todo消息队列实现方式，自己是这么想的

消费者要订阅消息，可以这么定义list的key，topic-consumer，有消息，就把消息push进去，消费者可以使用blpop类似的命令持续监听队列，这种是推的模式。

还可以采用拉的方式，消息放在一个list中，订阅者主动去拉其中的消息，如果拉取的人太多，感觉可以考虑多放几个key，把压力分散出去，就是对于微博的大v，首先对他们来说，主动推不是太现实，粉丝太多了，可以把消息发布到几个key中，粉丝基于一定路由访问这些key，做负载均衡的方式。

### 1.4 集合 set

常用操作

sadd增

smembers查

srandmember随机查

spop删

scard查数量

sismember

sinter 交集

sunion 并集

sdiff 差集

具体的实现思路类似于java中的hashmap，其中求集合关系的功能在关系运算之间用的比较多。

基于这些操作实现关注列表的操作，利用关注集合的交并差计算两个人之间的关注关系。

可以利用set实现随机抽取的操作，srandmember和spop都是随机抽取元素的操作，不同的是前者会把元素放回去，后者会删除对应的元素。

感觉smismember有点意思，即批量判断给定的元素是否在集合中出现，就是不知道这种执行效率怎么样，我理解的话应该还可以。

### 1.5 有序集合 zset

常用操作

zadd 增

zincrby 改

zrevrange 倒序排序

zunionstore 求并集，并存储结果

和set类似，但是有一个元素score，看起来就像是只有一个field的hash结构，利用这个score，可以实现排序的功能。

是有序的，每个元素带一个分值，一个类似的功能，新闻热搜可以使用这种思路简单实现。

### 1.6 功能总结

看起来是都会有一些统一的功能，例如对于数值型的类型，会有类似原子增，string、hash、zset都会有类似的功能。

对于set类型，会有类似集合的操作，相关的集合操作包括交集、并集、差集，同时支持把结果存入新的数据结构。

之后，会有一些通用的命令：

- keys

  模糊搜索所有满足条件表达式的key，数据量比较大的话，是一个极为耗时的操作，不建议在生产使用

- scan

  弥补keys的问题，可以按批搜索所有的key值，每次搜索一批

- info

  查看redis服务信息

## 2. redis线程模型

**是单线程的吗**

这里单线程是指接受网络请求以及键值对读取分别都是由一个线程完成（？所以说是两个线程对吗todo），网络io不会因为某一个请求卡住而不能接受其他请求，同时因为全程在内存中操作，键值读取不会太慢。除此之外，redis中其他功能，例如持久化、异步删除、集群数据同步等，都是由额外的线程完成的。

**为什么性能好**

所有数据都是在内存中存放，不存在线程切换的损耗，同时，耗时的指令要慎用，因为花时间在这个指令上，意味着其他指令不能及时执行。

**怎么处理大量客户端连接**

这里简单看下redis中的服务器模型，核心有两个，io多路复用器以及事件处理器，io多路复用器接收client请求，之后将任务分发给事件处理器，看起来事件处理器是串行处理的任务。redis之后的升级，引入了异步删除以及多线程io读取的特性，以充分利用多核的性能。所以事件处理器还是单线程的，但是网络io在6.0之后就可以采用多线程的方式来做了。

## 3. redis数据持久化

> 集群模式搭建
>
> redis-cli --cluster create --cluster-replicas 1 127.0.0.1:7011 127.0.0.1:7012 127.0.0.1:7013 127.0.0.1:7014 127.0.0.1:7015 127.0.0.1:7016
>
> cluster-replicas配置了主从复值比

正常生产环境的redis还是要做持久化的，正常的持久化模式有两种，rdb和aof

### 3.1 rdb快照

备份当前的内存的快照，配置开启方式如下：

```shell
save 3600 1
save 300 100
save 60 10000
```

类似于这种方式，如果在配置的时间段内有多少操作，即触发rdb备份，如上，可以设置多个条件。

执行rdb快照有两种方式：

- save

  和正常的redis命令相同，如果当前内存中数据较多，会影响redis中其他命令正常执行。

- bgsave

  为了不影响正常redis命令执行，使用异步多方式做备份，采用copy on write的方式来做备份，步骤如下：

  1. fork一个子进程开启备份，子进程可以共享主线程的所有内存数据
  2. 正常如果备份的时候没有修改操作，即直接备份
  3. 如果对某块内存有修改操作，即复制一块同样的内存空间，之后子进程备份复制出来的内存，主线程在原有内存空间继续做写入操作。

相对于save，bgsave不会阻塞redis其他命令，但是会有一定的内存消耗。

### 3.2 aof备份

> rdb快照这种模式中，考虑到对性能的影响，save逻辑不会配置的特别频繁，所以如果redis宕机，很有可能会有数据没有来得及持久化，append only file(aof)一定程度上可以解决这些问题。

aof的逻辑中，只要执行了redis修改命令，即记录到缓存中，之后在特定的时机写入aof文件中，执行时机有以下几种：

- appendfsync always

  每次有命令执行，即写入aof

- appendfsync everysec

  每秒进行一次aof写入

- appendfsync no

  不主动发起aof备份，交给系统决定是否开启aof

相对于rdb，aof默认的配置，最多会丢失1s内写入的数据，aof是追加新增的命令，而rdb是备份整个内存，肯定是aof会快一些。之后，重启的时候，redis即基于aof文件恢复数据，是一种重放的方式。

aof缺点很明显，日志文件会比较大，同时如果redis存的数据较多，恢复速度会比较慢。针对日志文件大的问题，aof会在一定的时机会重写其中的命令，即将原本多条命令整合成一条等效的命令，具体时机如下：

- aof超过一定大小，即自动重写，默认64m
- 如果aof文件增加了一倍，且超过了阈值，开启重写

### 3.3 具体选择

rdb和aof各有优劣，其中rdb备份相对于aof更慢，丢数据的概率更高，但是rdb数据格式更紧凑，占用空间小，恢复也更快。

|          | rdb  | aof  |
| -------- | ---- | ---- |
| 优先级   | 低   | 高   |
| 备份速度 | 慢   | 快   |
| 恢复速度 | 快   | 慢   |
| 占用空间 | 小   | 大   |
| 安全性   | 低   | 高   |

两种持久化方式本身不是冲突的，可以同时开启，redis重启的时候默认使用aof恢复数据，如果没有aof，即使用rdb。

**优化**

4.0之后，产生了一种**混合持久化**的方式，即在aof文件重写的时候，会先备份当前的内存快照文件，同时在备份期间的额外操作会以aof的方式追加到内存快照文件后。

恢复的时候，只会有少量的命令要重放，大量的工作即使用快照的方式恢复，提升了恢复速度，压缩了存储空间，同时也不至于丢失太多数据。同时，只有在触发重写的时候采用这种混合持久化方式，不至于太频繁。

## 4. redis主从模式

