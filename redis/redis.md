# redis

## 1. 常用数据结构

### 1.1 string

常用命令 

- set 

- get 

  spring session就是利用redis的string来存的

- del 

- setnx 

  分布式锁使用的命令

- mset 

- mget

- incr

  原子性+1，类似于juc的atomic机制

  场景：

  统计阅读量

  批量生成序列号

- decr

  原子性-1

通用增删改查

过期时间设置：setex

原子性设置：setnx，如存在即设置失败

原子性加减：incr、decr、incrby、decrby

批量设置 mset mget

bit相关操作

### 1.2 hash

常用命令

- 增删改查

  hset

  hsetnx 同string中的操作，如存在返回0，不存在设置并返回1

  hdel 删除某个hash中的key值

  Hget

  hmget

  hkeys 得到所有field

  hvals 返回所有value

  hexists 查看是否存在某个field

  Hrandfield 随机返回一个hash中的field，参数可以控制返回几个field，是否返回对应的value

  hincrby 某个field加给定值

  hincrbyfloat 某个field加给定小数

  hscan 类似scan的方式查找hash中的field，使用方式是hscan key cursor match pattern count n，这里cursor和存放数据的slot有一定关系todo

  

是一个 key -> value 的结构，其中value同样是key-value的结构

不同于string，hash的value也是一系列key-value的对，对于其中value的操作类似于string的操作，同样可以做原子加减

**场景**

对象缓存，存放对象的不同字段，如果key比较大，redis会比较麻烦

**优点**

相对string ，数据管理更紧凑，存储空间、性能方面更优

**缺点**

过期功能只能用到key中，不能用到field中

集群架构下不适合大规模使用？

### 1.3 列表list

**常用操作**

lpush

rpush

lpop

rpop

blpop

brpop

Lmove 在两个list之间移动元素

linsert 向list中指定位置插入元素

llen 长度

lpushx 只有当list存在才添加元素

lrem 删除一定数量的元素

ltrim 截取list

使用这些基本命令可以实现队列、栈以及阻塞队列、阻塞栈的形式。

常用的场景，例如消息队列

todo消息队列实现方式，自己是这么想的

消费者要订阅消息，可以这么定义list的key，topic-consumer，有消息，就把消息push进去，消费者可以使用blpop类似的命令持续监听队列，这种是推的模式。

还可以采用拉的方式，消息放在一个list中，订阅者主动去拉其中的消息，如果拉取的人太多，感觉可以考虑多放几个key，把压力分散出去，就是对于微博的大v，首先对他们来说，主动推不是太现实，粉丝太多了，可以把消息发布到几个key中，粉丝基于一定路由访问这些key，做负载均衡的方式。

### 1.4 集合 set

常用操作

sadd增

smembers查

srandmember随机查

spop删

scard查数量

sismember

sinter 交集

sunion 并集

sdiff 差集

具体的实现思路类似于java中的hashmap，其中求集合关系的功能在关系运算之间用的比较多。

基于这些操作实现关注列表的操作，利用关注集合的交并差计算两个人之间的关注关系。

可以利用set实现随机抽取的操作，srandmember和spop都是随机抽取元素的操作，不同的是前者会把元素放回去，后者会删除对应的元素。

感觉smismember有点意思，即批量判断给定的元素是否在集合中出现，就是不知道这种执行效率怎么样，我理解的话应该还可以。

### 1.5 有序集合 zset

常用操作

zadd 增

zincrby 改

zrevrange 倒序排序

zunionstore 求并集，并存储结果

和set类似，但是有一个元素score，看起来就像是只有一个field的hash结构，利用这个score，可以实现排序的功能。

是有序的，每个元素带一个分值，一个类似的功能，新闻热搜可以使用这种思路简单实现。

### 1.6 功能总结

看起来是都会有一些统一的功能，例如对于数值型的类型，会有类似原子增，string、hash、zset都会有类似的功能。

对于set类型，会有类似集合的操作，相关的集合操作包括交集、并集、差集，同时支持把结果存入新的数据结构。

之后，会有一些通用的命令：

- keys

  模糊搜索所有满足条件表达式的key，数据量比较大的话，是一个极为耗时的操作，不建议在生产使用

- scan

  弥补keys的问题，可以按批搜索所有的key值，每次搜索一批

- info

  查看redis服务信息

## 2. redis线程模型

**是单线程的吗**

这里单线程是指接受网络请求以及键值对读取分别都是由一个线程完成（？所以说是两个线程对吗todo），网络io不会因为某一个请求卡住而不能接受其他请求，同时因为全程在内存中操作，键值读取不会太慢。除此之外，redis中其他功能，例如持久化、异步删除、集群数据同步等，都是由额外的线程完成的。

**为什么性能好**

所有数据都是在内存中存放，不存在线程切换的损耗，同时，耗时的指令要慎用，因为花时间在这个指令上，意味着其他指令不能及时执行。

**怎么处理大量客户端连接**

这里简单看下redis中的服务器模型，核心有两个，io多路复用器以及事件处理器，io多路复用器接收client请求，之后将任务分发给事件处理器，看起来事件处理器是串行处理的任务。redis之后的升级，引入了异步删除以及多线程io读取的特性，以充分利用多核的性能。所以事件处理器还是单线程的，但是网络io在6.0之后就可以采用多线程的方式来做了。

## 3. redis数据持久化

> 集群模式搭建
>
> redis-cli --cluster create --cluster-replicas 1 127.0.0.1:7011 127.0.0.1:7012 127.0.0.1:7013 127.0.0.1:7014 127.0.0.1:7015 127.0.0.1:7016
>
> cluster-replicas配置了主从复值比

正常生产环境的redis还是要做持久化的，正常的持久化模式有两种，rdb和aof

### 3.1 rdb快照

备份当前的内存的快照，配置开启方式如下：

```shell
save 3600 1
save 300 100
save 60 10000
```

类似于这种方式，如果在配置的时间段内有多少操作，即触发rdb备份，如上，可以设置多个条件。

执行rdb快照有两种方式：

- save

  和正常的redis命令相同，如果当前内存中数据较多，会影响redis中其他命令正常执行。

- bgsave

  为了不影响正常redis命令执行，使用异步多方式做备份，采用copy on write的方式来做备份，步骤如下：

  1. fork一个子进程开启备份，子进程可以共享主线程的所有内存数据
  2. 正常如果备份的时候没有修改操作，即直接备份
  3. 如果对某块内存有修改操作，即复制一块同样的内存空间，之后子进程备份复制出来的内存，主线程在原有内存空间继续做写入操作。

相对于save，bgsave不会阻塞redis其他命令，但是会有一定的内存消耗。

### 3.2 aof备份

> rdb快照这种模式中，考虑到对性能的影响，save逻辑不会配置的特别频繁，所以如果redis宕机，很有可能会有数据没有来得及持久化，append only file(aof)一定程度上可以解决这些问题。

aof的逻辑中，只要执行了redis修改命令，即记录到缓存中，之后在特定的时机写入aof文件中，执行时机有以下几种：

- appendfsync always

  每次有命令执行，即写入aof

- appendfsync everysec

  每秒进行一次aof写入

- appendfsync no

  不主动发起aof备份，交给系统决定是否开启aof

相对于rdb，aof默认的配置，最多会丢失1s内写入的数据，aof是追加新增的命令，而rdb是备份整个内存，肯定是aof会快一些。之后，重启的时候，redis即基于aof文件恢复数据，是一种重放的方式。

aof缺点很明显，日志文件会比较大，同时如果redis存的数据较多，恢复速度会比较慢。针对日志文件大的问题，aof会在一定的时机会重写其中的命令，即将原本多条命令整合成一条等效的命令，具体时机如下：

- aof超过一定大小，即自动重写，默认64m
- 如果aof文件增加了一倍，且超过了阈值，开启重写

### 3.3 混合备份

rdb和aof各有优劣，其中rdb备份相对于aof更慢，丢数据的概率更高，但是rdb数据格式更紧凑，占用空间小，恢复也更快。

|          | rdb  | aof  |
| -------- | ---- | ---- |
| 优先级   | 低   | 高   |
| 备份速度 | 慢   | 快   |
| 恢复速度 | 快   | 慢   |
| 占用空间 | 小   | 大   |
| 安全性   | 低   | 高   |

两种持久化方式本身不是冲突的，可以同时开启，redis重启的时候默认使用aof恢复数据，如果没有aof，即使用rdb。

**优化**

4.0之后，产生了一种**混合持久化**的方式，即在aof文件重写的时候，会先备份当前的内存快照文件，同时在备份期间的额外操作会以aof的方式追加到内存快照文件后。

恢复的时候，只会有少量的命令要重放，大量的工作即使用快照的方式恢复，提升了恢复速度，压缩了存储空间，同时也不至于丢失太多数据。同时，只有在触发重写的时候采用这种混合持久化方式，不至于太频繁。

## 4. redis高可用模式

主从模式中，在slave配置文件中，master的ip看起来是写死的。主从同步的顺序如下，这里是**全量同步**：

1. 使用psync命令同步数据，发送命令之前会跟主节点建立socker长连接
2. 主节点收到psync命令之后，执行bgsave生成rdb快照
3. 快照文件生成之后，向slave发送rdb快照文件
4. slave收到文件之后，会清空旧数据，之后加载新的rdb文件
5. 在生成rdb文件以及发送rdb文件的过程中，也会有写入命令，所以主节点会把repl buffer中的命令发送给从节点
6. 从节点执行收到的命令，写入到内存
7. 之后主节点每次执行更新命令，就通过socker长连接通知到从节点

如果从节点短暂断开，之后重新连接到主节点，会请求主节点开始断点续传的步骤，即master会创建一个和slave同步数据的缓存队列，master和它的所有slave都维护了master进程的id以及缓存队列的下标offset，之后slave断开了，会请求master同步数据，如果发现mater进程id变了或者slave的offset已经不在缓存队列中了，就转换为全量复制，如果还在，master就只把offset之后的命令同步给slave，这就是**断点续传**的机制。

同时为了避免主节点下直接连接的从节点过多，可以考虑从节点也分下层次，即有的从节点从其他从节点同步数据。

### 4.1 哨兵模式

单纯的主从架构是全手动的模式，如果主节点挂了，就要人工参与了，针对这种场景，即有了哨兵模式。

哨兵模式下，客户端和服务端中间加了一个哨兵集群，其中维护了主从结构的信息，客户端从哨兵集群中得到主节点的链接信息，同时在哨兵那里注册了监听机制，一旦主节点挂了，哨兵会重新组织选举，这里的选举是哨兵选举，即每个哨兵给剩余存活的节点投票，并把新的主节点信息给予前面的监听机制通知给客户端。

![截屏2022-10-05 10.21.07](../截屏2022-10-05 10.21.07.png)

哨兵使用redis-sentinel命令启动，使用的配置文件为sentinel.conf。其中的核心配置是：

```shell
sentinel monitor <master-name> <ip> <redis-port> <quorum>
```

其中quorum指的是有多少哨兵发现主节点挂了，才会开始新的选举，最好是n/2 + 1个，n是哨兵的数量，即半数以上，从这里看，哨兵数量最好配置成奇数，保证不会出现一半一半的情况。

<font color='red'>真的一辈子都配置不好docker中的 redis sentinel 难受，之后专心看集群吧，真的难受，还是之前这个配置，之后就生效了，是因为sentinel会主动修改slave的conf，导致主从结构失效了</font>

### 4.2 集群模式

哨兵模式下：

如果主节点失效，之后依赖哨兵的投票，投票过程中，会有一段时间的服务不可用；

只有主节点对外提供服务，同时，只有一个节点提供服务，意味着为了存放更多的数据，单节点的内存会更大，持久化以及主从备份的压力也会更大。

所以，哨兵模式适用于访问量不大、期望存储空间不大、能容忍因为选举带来的短暂停顿的场景，但是，如果并发访问压力较大，数据较多的场景，哨兵就有点吃紧了，所以就有了集群模式。

集群模式中，将所有的key基于hash分散到多个节点，同时每个节点都会有备份的slave节点，即分成多个主从的小集群，结构如下：

![截屏2022-10-05 16.29.24](../截屏2022-10-05 16.29.24.png)

因为做了类似分片的操作，将原来打到一个master节点的流量打到了多个节点上，同时虽然也会有短暂断连的停顿，但是分散到了多个节点，一个节点有问题，其他节点还是可以用。

这里可以用docker compose搭建redis集群，每个节点注意把集群模式打开，如果配置ip的话，记得在bind后面加上对应ip。

之后登陆了集群中的某台机器，使用cluster命令可以查看集群的状态信息，包括cluster info或者cluster nodes等。

----

集群模式下，虚拟出了16384个slot，翻译过来叫槽位，这些槽位均匀分布到初始化的主节点上，当要操作对应的key的时候，对key进行crc16运算，之后对16384取余数，得到要放到哪个槽位，之后进而对应到master节点。之后的操作只能在主节点进行，即便在从节点请求，也会重定向到对应主节点。

使用类似于jedis的客户端访问集群的时候，会在建立连接的时候把cluster nodes信息取出来，得到哪些master节点存哪些slot，之后对key做操作的时候，会首先自己算出来对应的key是哪个slot，之后基于slot得到要请求的节点信息，之后就请求该节点，如果位置是对的，就等待操作结果就ok了，如果slot被迁移到了其他节点，就会返回一个重定向信息，其中包含对应机器信息，之后就更新slot映射信息然后请求对应地址，之后不排除下一次还会要求被重定向，不可能一直重定向的，所以就是可以配置一个最大重定向地址。

-------

集群模式下，节点之间是通过gossip协议相互通信的，通信端口是正常端口+10000。





## 5. redis命令执行

### 5.1 管道命令

jedis提供了一种管道的机制，即一次发送多个命令，服务端收到管道发送来的请求之后，依次执行这些命令，并一次返回执行结果。管道命令没有原子性，同时也没有事务机制，执行代码如下。

```java
try(Jedis resource = jedisPool.getResource()) {
    final Pipeline pipelined = resource.pipelined();
    for (int i = 0; i < 10; i++) {
        pipelined.incr("pipelinekey");
        pipelined.set("sgw" + i, "sgw");
    }
    final List<Object> objects = pipelined.syncAndReturnAll();
    objects.forEach(System.out::println);
}
```

使用管道命令可以减少网络请求的时间，一次请求多条命令，服务端执行完所有命令之后，一次返回所有执行结果。但是，这样势必会占用服务端更多的内存空间，是一个辩证的过程。

### 5.2 lua脚本

相对于没有原子性的管道而言，lua脚本是支持原子性以及事务的。即一段lua脚本的操作，redis server端是当作一条命令执行的，且具备原子性，天然支持事务，比较安全。

|                          | 管道 | lua脚本 |
| ------------------------ | ---- | ------- |
| 原子性                   | 否   | 是      |
| 事务                     | 否   | 是      |
| 是否可以穿插执行其他命令 | 是   | 否      |



