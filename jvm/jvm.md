# jvm

## 1. 类加载器

> 使用java命令启动一个java程序，会启动一个jvm，即java虚拟机，而java虚拟机中具体执行代码之前就是要加载所需要的类，加载类的工作是由类加载器实现的

### 1.1 加载器层级

jvm启动的时候，首先会由c++程序启动一个引导类加载器，即bootstrap类加载器；

之后由该类加载器加载Launcher类，其中会构建扩展类加载器以及应用类加载器；

构建的类加载器之间是有层级关系的，从逻辑而言从上到下依次是：

- 引导类加载器

  加载jre/lib下面的核心包，如Object String等

- 扩展类加载器

  加载jre/lib/ext下面的扩展包，现在可以理解成插件的形式

- 应用类加载器

  加载java程序启动时候传入的classpath下的包，java中代码中自定义加载器的父加载器就是应用类加载器

### 1.2 类加载过程

#### 1.2.1 双亲委派机制

jvm中默认采用双亲委派机制来加载类，具体过程如下：

1. 首先看当前加载器中是否已经加载了该类，如果有，直接返回

2. 如果没有，则从父加载器中去找

   1. 父加载器中也会采用相同的流程

      扩展类加载器的父加载器属性那里是空，代码中这么定义的，如果父加载器为空，则从引导类加载器中去找

   2. 父加载器中load class的代码忽略了classnotfound的错

3. 父加载器中也没找到，就执行自己定义的具体加载流程，即findclass，这里可以根据自己的需要扩展出对应的加载器，如urlclassloader，或者如果想要从remote加载类，就是根据传进来的名字从远端去读，之后加载。

一个简单的自定义类加载器只需要重写findclass方法，如下：

```java
/**
 * 核心方法，双亲委派机制由自带的loadclass实现，如果父类没有，即调用该方法
 * @param name
 * @return
 * @throws ClassNotFoundException
 */
@Override
protected Class<?> findClass(String name) throws ClassNotFoundException {
    String packagePath = name.replaceAll("\\.", "/");
    try {
        FileInputStream fileInputStream = new FileInputStream(classPath + packagePath + ".class");
        byte[] content = new byte[fileInputStream.available()];
        fileInputStream.read(content);
        return defineClass(name, content, 0, content.length);
    } catch (IOException e) {
        throw new ClassNotFoundException();
    }
}
```

**优点**

这种设计模式肯定是有自己的考虑的：

- 这样提供了一种沙箱的机制，防止核心类库被重新覆盖（从代码看，其他也会有地方去考虑的，比如，默认的classloader的loadfrombyte方法中，就不允许加载java开头包名下的类）

- 提升效率吧

  这样对于同样的包，就不要重复加载了，都在同一个地方去读

**不足**

这种加载模式保证了一个包只会加载一次，因为首先是从父加载器中取的，但是如果说我有几个子加载器，想要在这几个子加载器中分别加载不同版本的一个包，比如不同版本的spring，这种就会有点问题，因为如果委托父加载器去做，那么对于同一个包，只会有一个版本。

一个简单的思路就是重新调整下loadclass，即对于特定的包，由子类加载器负责，这样就能实现多版本包并存，如下：

```java
@Override
protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
    synchronized (getClassLoadingLock(name)) {
        // First, check if the class has already been loaded
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            if (name.startsWith("java1")) {
                c = findClass(name);
            } else {
                c = getParent().loadClass(name);
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```

**具体场景**

一个很实用的场景就是tomcat的加载过程，几个不同的webapplication，它们的spring版本可能不同，那么就需要分别在自己的子加载器中去加载。对于每个应用程序自己依赖的包，即使用自己的类加载器加载，即从自己的路径下去找，如果是公共的包，即交给父类加载器。

#### 1.2.2 具体加载过程

- 加载

  把字节码（class）文件加载到内存

- 验证

  验证字节码文件是否符合java的规范，这里就要看，是否是在自定义加载器中加载了java开头的包这种安全问题

- 准备

  给类的静态变量分配内存，并赋予默认值，对于基本类型，都会有一个默认值，如果是引用类型，赋值为null

- 解析

  符号引用 -> 直接引用

  这里**符号引用**指的是java中的引用，**直接引用**，即真实地址。

  完成**静态链接**的过程，即类加载期间做完上述过程。

  这里主要针对静态的方法，对于非静态的部分，需要**动态链接**，即程序运行期间执行上述过程。

- 初始化

  类的静态变量赋值，同时执行静态代码块

java程序启动的过程是一个懒加载的过程，对于一个类，只有在用它的时候，才会加载。对于程序员而言，加载一个类的具体启动顺序为：

1. 静态变量

2. 静态代码块

3. 常量

4. 构造代码块

5. 构造方法

## 2. jvm内存模型

java语言天然具有跨平台的特性，不同平台的区别体现在不同的jdk版本上，它们能识别同样的class文件，并转化为对应平台的机器码命令。jvm诞生的时候，正处于c/c++盛行的时代，很自然的它就是在c/c++的基础上诞生的，包括java程序启动，一些类加载器，字节码执行引擎，jvm内存模型中的很多部分都是由c/c++做的。

> jvm组成
>
> - 类装载子系统
>
> - 内存模型
>
>   jvm调优主要是针对这里做的
>
> - 字节码执行引擎

下面着重介绍jvm内存模型

### 2.1 jvm内存模型组成

内存模型由jvm栈、程序计数器、本地方法栈、堆、方法区五部分构成，其中前三部分是每个线程独有，即开启一个线程，就会单独分配这三部分空间，后两部分是线程共享的。

- jvm栈

  **线程独有**

  给线程分配的内存空间，用于存放线程内部的局部变量，保证了线程安全

  每个线程的栈是由一个个栈帧构成，每个栈帧对应一个方法，只有最上层的栈帧是激活状态，这里用栈描述了方法的调用关系，这个栈的容量是有限制的，所以不可能无限的调用，每个栈帧包含了如下信息：

  - 局部变量表 

    基本类型的值、指向堆中的地址

  - 操作数栈

    是一块中转存放的内存空间，执行具体操作的值，包括操作类型，操作的值是从局部变量表中取的

  - 动态链接 

    指向运行时常量（方法区）的地址

  - 返回地址

    指向调用该方法的栈帧地址 

- 本地方法区

  **线程独有**

  如果调用本地方法，即C++方法，会放在本地方法区，java最早诞生的时候，这种场景会比较多，原有的c++/c程序要向java过渡，在过渡的中间状态，免不了会有java调用c++/c程序的场景，这里更具体的是调用对应的dll动态链接库，在jdk的代码中还会有很多这种场景。

- 程序计数器

  **线程独有**

  表示当前线程的执行位置，用户线程切换的时候重新进行定位

- 堆

  存放对象的具体内容，其他地方，例如局部变量表、方法区中存放的都是地址，最终指向堆中，因而，堆是jvm内存模型中占用空间最大，且变化较为频繁的区域。

  根据对象的存活时间，分为年轻代、老年代俩部分：

  - 年轻代

    包括eden（意为伊甸园，即对象出生的地方） s0 s1三部分区域，一般比例是8:1:1，这里区域划分是为了方便之后的垃圾回收。应该是有一个参数配置这个比例。

  - 老年代

    一般占2/3的空间，一般而言，存活较久的对象会被放到老年代中。

  对象会有一个比较重要的属性，年龄，经过一次gc存活下来，年龄加一，一般到15之后，即被放到老年代，证明不会轻易被回收。这里取15是因为存放age的地方在对象头中，而对象头中只为age分配了4位的空间，所以age最大是15。

- 方法区

  包含加载的类、方法、常量、静态变量，是多个线程之间共享的。

  这个是1.8之后做了一定的改动，是直接用的物理内存，如果不设置，默认初始值是21M，之后根据具体使用情况进行缩小或者扩张。每次缩小或者扩张，都是在full gc之后做的，而full gc是比较耗费时间的，故对于规模较大的程序，如果没有设置方法区初始大小，启动过程中，会频繁因为方法区不够而触发full gc，拖慢启动速度。

### 2.2 jvm启动参数

这里列举了常用的针对jvm内存模型大小设置的启动参数：

- 堆

  - Xms 堆大小的最小值

  - Xmx 堆大小的最大值

  - Xmn 年轻代大小

    一般这里Xms和Xmx设置成一样的值，一次分配到位，防止因为堆空间不足触发gc，拖慢系统运行。

  
  - XX:+UseAdaptiveSizePolicy
  
    这个参数会自动调整eden以及s0 s1之间的比例
  
  - Xss 线程栈大小
  
    这里是启动一个线程，jvm给它分配的内存大小，一般而言，对于io密集型程序，可以稍微小一些，对于运算密集型程序可以稍微大一些。
  
  - XX:MetaspaceSize 方法区触发fullgc的初始值
  
  - XX:MaxMetaspaceSize 方法区最大大小
  
    同堆大小设置，这里一般也会设置成相同的配置，视程序大小来设置，**一定要有**，否则就会采用默认初始值，拖慢系统启动速度，具体解释见2.1方法区介绍。

### 2.3 jvm gc初探

这里大体讲下gc的概念，语义上是垃圾回收，即空间不够用的时候，做的一步就是回收不会再被使用的对象。对于gc，有两个重要的概念，**gc root**、**stw**，前者是gc过程中进行对象引用标记的起点，由gc root开始，把被引用到的对象标记出来，意思是它们目前还在使用，不要回收，剩余的对象没有引用，则可以被当成垃圾回收。同时，由gc root开始做对象引用标记的过程中，需要所有的用户线程停止一切动作，否则会导致标记结果不准确，在这个过程中对于jvm中的用户线程而言，世界都停止了，所以这个过程被称为stop the world，即stw。stw因为设计所有用户线程的停止运行，故会影响java程序的流畅性。

gc分类：

- young gc

  针对年轻代的gc，前面讲解年轻代的空间的时候，提到年轻代有eden、s0、s1三部分构成，所有对象都是构建在eden中的，如果eden中的空间不够用了，即触发young gc，期间会stw，并找到还有被引用的对象，存放到s0中，之后清空eden以及s1中的对象，之后程序继续运行，直到eden空间又不够了，同样会stw，找到还有被引用的对象，放到干净的s1中（因为s1已经在上一轮gc中被清空）。。。。

  所以这里s0、s1是交替使用的关系，任意时刻，这两个区域总有一个是干净的，用于存放下一次gc之后还存活的对象。

  对于经过一次gc存活下来的对象，它的**age**会加一，当age足够大，会在适当的时机被放到老年代中，可能是存放存活对象的s区域不够用了或者是其它原因。

- full gc

  如果老年代经过一段时间程序运行，空间也不够了，或者方法区在程序启动过程中，空间不够了，就会触发full gc，相对于young gc，它耗费的时间要大的多，因为这里要扫描所有的对象，而young gc中只会扫描年轻代中的对象，因而full gc中stw时间会久一些。故full gc是要尽量避免的，之后的jvm调优中，一部分内容就是讲怎么避免频繁触发full gc。

讲义中讲了一个例子，说对于一个大促过程中的系统，产生对象的速度要比平时多很多，同时这些对象也会很快变成垃圾对象，这些对象都是在年轻代中生成、存放的，为了避免full gc，即这些垃圾对象在被回收之前进入老年代，可以考虑增加年轻代的空间，尽量让垃圾对象一直在年轻代中，到下次触发young gc的时候直接被回收。

系统的jvm参数应该是可以根据具体场景估算出来的，即根据要承担的压力来判断。

### 3. jvm对象创建

- 类加载检查

- 内存分配

  - 指针碰撞

    针对内存空间是连续分配的情况

  - 空闲列表

    针对内存空间是不连续的情况

  这两种分配方式都会有并发问题，即两个线程竞争分配内存，如果不加以控制，可能会取到相同的空间，为了解决并发问题，有两种方案：

  - cas，保证同时只有一个线程竞争成功
  - tlab，thread local allocation buffer，1.8之后，默认采用这种方式，即在eden中给每个线程分配一块空间，不同线程操作自己分配到的那块，避免冲突，默认分配的空间大小是eden大小的1%，如果放不下，就使用cas的方式去竞争。

- 初始化

  将分配到的内存空间初始化为零值

- 设置对象头

  堆中对象分配堆空间主要是由 对象头、实例数据、填充部分（保证对象大小是8字节的整数倍，这里是考虑提升运行效率） 构成。对象头记录了一个对象在jvm中通用的一些属性，包括类型指针、age、加锁情况等。
  
  对象头组成：
  
  - mark word
  
    占用大小 32位-4byte 64位-8byte
  
    一般是有锁状态、hashcode、分代年龄、锁标志位这些部分，具体的根据不同的锁状态有不同的结构
  
  - klass pointer
  
    这里开头就是k，没问题，是从c++源码中来的。
  
    开启压缩 占用4byte，java一般默认开启指针压缩，不开的话，64位系统地址应该是8位，开了之后就是4位。
  
    类型指针，指向方法区的类元数据，即标识该对象的类型，真正使用这些信息的应该是c++代码调用的。
  
    正常我们java代码中使用的Class<?>对象，是给java程序用的，提供到方法区类元数据的指针，反射等方式就是以它为开端的。
  
  - 数组长度
  
    如果对象是一个数组，则有这部分，占用4个字节。
  
- 执行<init>方法

  成员变量赋值，执行构造方法

**指针压缩**

-XX:-UseCompressedOops 默认开启

压缩所有指针

-XX:-UseCompressedClassPointers

只压缩对象头中的klass point

之前32位操作系统受限为寻值范围，支持的最大内存为4g，对于目前普遍的64位操作系统，支持的内存基本不会成为之后性能的瓶颈，同时，也会有大量的冗余位，目前机器普遍还是以g为单位的，对于32g的内存，只用35位就ok了，开启压缩，即把这些35位数据压缩为32位。

1. 机器内存小于4g的时候，不需要开启指针压缩，jvm会直接丢弃高32位即可
2. 小于32g的时候，即压缩成32位
3. 大于32g的时候，压缩失效，指针大小还是会64位

所以，服务器内存超过32g之后，强制使用64位地址，占用内存空间会变大。

**对象内存分配**

-XX:+DoEscapeAnalysis，开启逃逸分析 默认开启

-XX:+EliminateAllocations 开启标量替换 默认开启

对象是可以考虑直接申请线程栈中的空间，但是是在对象的作用域只会在当前方法中，不会在方法外被使用，如果可以分配的话，即直接在当前方法对应的栈帧中申请一块空间，这样申请的对象不需要gc来管理，方法结束，对象会随着栈帧被释放，以上的分析过程即**逃逸分析**，同时，通过逃逸分析之后，确定可以直接在线程栈中的对象，如果对象可以做进一步分解，jvm不会创建对象，而是分别创建其中的成员变量，这个过程叫做**标量替换**，标量即不能被分解的量，相对于标量，会有一个**聚合量**，即可以做进一步拆分的变量。

确定会创建在堆中，首先考虑的会在tlab中创建，如果不够，即通过cas竞争在eden中创建，空间不够，触发young gc，如果太大会直接创建在老年代。同时在使用serial和parnew两种垃圾收集器的情况下，可以通过-XX:PretenureSizeThreshold设置大对象的大小。如果有创建的对象足够大，超过设置的阈值，即直接放到老年代，因为正常对象进入老年代之前，做young gc的时候会在eden以及from、to区域之间来回赋值，为了提升效率，则直接进入老年代。

默认情况下，一个对象的age到15，才会进入老年代。如果针对实际情况，我们看到系统中的大部分对象基本生命周期比较短，不要经过15次gc就会被干掉，可以把这个age设置的时间短一些，确定经过了那么几次gc之后都已经基本是钉子户了，即可以直接进入老年代。

实例：

内存空间不是太够的时候，还没有打开逃逸分析，确实会导致太多的gc，拖慢系统运行，如下配置就很糟糕：

-Xmx15m -Xms15m -XX:+PrintGC -XX:-DoEscapeAnalysis

1.8中默认的逃逸分析是打开的，从这个极端的例子是可以看到一些效果的

-Xmx15m -Xms15m -XX:+PrintGC -XX:+DoEscapeAnalysis

**对象动态年龄判断机制**

经过young gc之后，如果进入survivor的一批对象中，年龄 1 + 2 + ……+n的对象大小加起来超过s区域大小的50%，那么年龄大于等于n的对象会提前进入老年代，设计的本质是为了减少持久对象经过young gc的次数，提升效率，但是如果年轻代空间不是太够，或者短时间内生成的临时对象骤增，也会导致一些临时对象因为体量太大，而进入老年代。

**老年代空间分配担保机制**

每次进行young gc之前，如果老年代中的剩余空间小于年轻代中所有对象大小：

之后如果没配置-XX:-HandlePromotionFailure参数，就判定之后老年代空间大概率会不够用，则直接进行full gc，或者如果配置了该参数，即判断老年代中剩余空间是否大于之前经过young gc之后进入老年代的平均对象大小，如果小于，才做full gc。

这里是一种担保机制，即便年轻代中存活对象大于老年代中的可用空间，但是，从之前的经验看，老年代的空间应该够用，因为可用空间是大于之前经过young gc之后进入老年代的平均大小，所以不进行fullgc。1.8中默认是开启这种机制的。

**对象内存回收**

判断对象是否要被回收

- 引用计数

  一个对象有被引用一次，对应的计数器即加一，之后扫描的时候，计数器值为0的对象即判定为垃圾，但是对于循环引用的场景，这种判断方式不是太合理，a引用b，b引用a，除此之外，再没有引用指向它们，从实际出发，它们都是垃圾，但是又都有引用，所以就有点问题。

- 可达性分析

  从gcroot为起点，向下搜索引用对象，被引用到的，即不会标记为垃圾，这样就不会找到那些循环引用变量。

  gcroot一般从线程栈本地变量？ 静态变量 局部变量表等中取

常见引用类型

- 抢引用

- 软引用

  todo 看具体应用

  gc的时候不会主动释放，但是如果空间不够用了，就会释放掉

  对于一些重要性不大的对象，可以使用软引用缓存

- 若引用

- 虚引用

**finalize（）**

对象要被回收的时候，如果对象重写了finalize方法，会执行该方法，如果此时该对象又有到gc root的引用了，不会被回收。

**如何判断一个类是无用的类**

full gc的时候，会扫描方法区，一个类元数据被回收要满足几个条件：

- 该类的所有对象实例都已经回收
- 加载该类的classloader已经被回收（有点苛刻），这种是对应自定义的classloader
- 对应的class对象也已经被回收

## 4. 垃圾收集器

前面已经讲了很多gc相关的东西，基本是什么时候做gc，这里具体讲的是怎么去做垃圾回收。

### 4.1 垃圾收集算法

- 分代收集理论

  把堆分成年轻代和老年代，对象基于创建时间、大小等被分别放到不同的内存区域。

- 标记复制

  把内存空间分为两部分，一部分空白，一部分有数据，之后做垃圾扫描，把不是垃圾的对象标记出来，标记结束之后，把标记的对象放置于空白的内存空间；

  这样效率比较高，但是如果非垃圾对象占比较大，所需的空白内存空间就会比较大，浪费空间。

- 标记清除
  进行垃圾扫描，把垃圾对象标记出来，之后删除标记出来的对象，删除结束之后，内存空间就变成了碎片化的空间，不太好。

- 标记整理
  和标记清除不太一样的，是标记之后，把非垃圾对象移位，整理空间，之后把空出来的空间抹除，这样就不会有碎片化的空间了；

  标记过程是比较浪费时间的。

**垃圾收集器**

是对垃圾收集算法的具体实现，针对不同的场景会有不同的垃圾收集器。

- serial收集器

  串行收集器，是前面一直讲的模式，使用单一线程工作，可达性分析之后，即进行垃圾处理。年轻代使用标记复制，老年代使用标记整理。

  年轻代和老年代是分开适配的，一个是serial 一个是serialold

- parallel收集器

  相对于serial，采用了多线程的方式，是jdk1.8的默认垃圾收集器

- parnew收集器

  只能用于年轻代，和parallel类似，区别就是可以配合cms使用

- cms

  concurrent mark sweep，针对老年代的垃圾收集器，如名称，使用了并发标记清除算法。

  1. 初始标记

     需要stw，找到gc root直接引用的对象

  2. 并发标记

     从直接引用对象出发，做可达性分析，做进一步标记，这里标记线程和用户线程同时运行，不需要stw

  3. 重新标记

     上一步，标记过程，用户线程没有停止，所以标记结果会有误差，这里stw，重新标记下

  4. 并发清除

     并发清除之前没标记的垃圾对象

  5. 并发重置

     重置标记数据

  cms主要是为了提升用户体验，stw的时间比较短，有助于提升吞吐量。应该也就是因为它清理的过程中，用户线程还在执行，所以才是做了标记清除，而不是标记整理，因为其他没有标记的对象不一定是垃圾。中间主要用了**三色标记算法**。

  这里并发标记以及并发清理的过程中，垃圾收集线程会和用户线程抢占cpu，如果是io密集型的程序，性能损耗应该还ok。

  parallelold相比于cms有更高的吞吐量，cpu使用效率更高，但是stw时间较长，而cms吞吐量不高，因为垃圾收集过程中，用户线程还是会有机会运行的，但是cms停顿时间短，用户体验好，所以从这个角度讲，如果服务是计算密集型，且不直接给用户提供服务，或者用户可以容忍停顿时间，parallel old会比较适合，如果是io密集型，如用户下单服务这些对用户体验有要求同时计算量不是太大的场景，cms就比较友好，stw时间短，相对parallel old，用户基本不会感受到停顿，请求会很快被响应。所以目前，这种高吞吐量的服务，对内存可能需求高一点，对cpu要求反而可能不是顶级的，占用内存高，如果还是用长stw的垃圾收集算法，停顿时间就会比较大了。

  因为stw时间短，所以cms整个垃圾收集时间会比较久，相当于一心两用了，而parallel old则比较专注，垃圾收集时间短。
  
  **缺点**：
  
  - 垃圾清理线程会和用户线程竞争资源
  - 并发清理的过程中会产生新的垃圾，即浮动垃圾，只能等到下次gc的时候再清理
  - 采用的是标记清除算法，单纯的cms会产生内存碎片
  - 因为cms工作线程和用户线程同时执行，此时，如果用户线程又产生新的大对象放到老年代中，此时会有问题，即 concurrent mode failure，此时即stw，之后使用serial old收集器来做
  
  **核心参数**
  
  > jvm参数中带的x越多，参数越不稳定，可能会在之后的版本被废弃
  
  - 控制cms启用
  - 控制并发线程数
  - 控制是否开启压缩整理（减少碎片）
  - 控制老年代空间占用比例到多少开始full gc，默认92，不等到老年代满了，就开启full gc，防止老年代过满，导致并发标记或者并发清理的时候再次触发full gc
  
  jvm参数考虑：
  
  - xms
  
  - xmx
  
  - xmn
  
  - metaspacesize
  
  - metaspacemaxsize
  
  - survivorratio eden的比例
  
  - 老年代的最大年龄
  
  - 大对象的大小阈值
  
    以上两个结合具体情况分析，看下大概多久触发一次young gc，以及临时对象一般可以存活多久
  
  - 开启full gc之后的压缩整理
  - 多少次full gc之后进行压缩整理，视full gc的触发频率来定

**三色标记**

扫描过程中，对象会有三种状态

- 黑色 所有成员变量已经被扫描，之后不会再处理
- 灰色 扫描了一部分
- 白色 没有被扫描到

中间会出现一些问题包括多标、漏标的情况，多标还好，如果是漏标，就会出现有被引用的情况被删除。

针对漏标有两种方案

- 增量更新

  并发标记的时候，如果有黑色对象的引用关系发生变化，将其标记为灰色，之后在做重新标记的时候，再扫一次

- 原始快照

  当灰色对象有引用被删掉了，会记录这些被删掉的引用，之后重新标记的时候，把这些被记录的引用标记为黑色，如果被删除的引用之后没有用了，那么这么整就会产生浮动垃圾了，但是这样操作之后，不会有对象被误删除

增量更新、原始快照都是基于写屏障实现的。写屏障类似于aop，在更新引用关系前后插入一些操作，这里记录删除关系以及重新标记对象都是可以在插入的逻辑中实现。





