# jvm

## 1. 类加载器

> 使用java命令启动一个java程序，会启动一个jvm，即java虚拟机，而java虚拟机中具体执行代码之前就是要加载所需要的类，加载类的工作是由类加载器实现的

### 1.1 加载器层级

jvm启动的时候，首先会由c++程序启动一个引导类加载器，即bootstrap类加载器；

之后由该类加载器加载Launcher类，其中会构建扩展类加载器以及应用类加载器；

构建的类加载器之间是有层级关系的，从逻辑而言从上到下依次是：

- 引导类加载器

  加载jre/lib下面的核心包，如Object String等

- 扩展类加载器

  加载jre/lib/ext下面的扩展包，现在可以理解成插件的形式

- 应用类加载器

  加载java程序启动时候传入的classpath下的包，java中代码中自定义加载器的父加载器就是应用类加载器

### 1.2 类加载过程

#### 1.2.1 双亲委派机制

jvm中默认采用双亲委派机制来加载类，具体过程如下：

1. 首先看当前加载器中是否已经加载了该类，如果有，直接返回

2. 如果没有，则从父加载器中去找

   1. 父加载器中也会采用相同的流程

      扩展类加载器的父加载器属性那里是空，代码中这么定义的，如果父加载器为空，则从引导类加载器中去找

   2. 父加载器中load class的代码忽略了classnotfound的错

3. 父加载器中也没找到，就执行自己定义的具体加载流程，即findclass，这里可以根据自己的需要扩展出对应的加载器，如urlclassloader，或者如果想要从remote加载类，就是根据传进来的名字从远端去读，之后加载。

一个简单的自定义类加载器只需要重写findclass方法，如下：

```java
/**
 * 核心方法，双亲委派机制由自带的loadclass实现，如果父类没有，即调用该方法
 * @param name
 * @return
 * @throws ClassNotFoundException
 */
@Override
protected Class<?> findClass(String name) throws ClassNotFoundException {
    String packagePath = name.replaceAll("\\.", "/");
    try {
        FileInputStream fileInputStream = new FileInputStream(classPath + packagePath + ".class");
        byte[] content = new byte[fileInputStream.available()];
        fileInputStream.read(content);
        return defineClass(name, content, 0, content.length);
    } catch (IOException e) {
        throw new ClassNotFoundException();
    }
}
```

**优点**

这种设计模式肯定是有自己的考虑的：

- 这样提供了一种沙箱的机制，防止核心类库被重新覆盖（从代码看，其他也会有地方去考虑的，比如，默认的classloader的loadfrombyte方法中，就不允许加载java开头包名下的类）

- 提升效率吧

  这样对于同样的包，就不要重复加载了，都在同一个地方去读

**不足**

这种加载模式保证了一个包只会加载一次，因为首先是从父加载器中取的，但是如果说我有几个子加载器，想要在这几个子加载器中分别加载不同版本的一个包，比如不同版本的spring，这种就会有点问题，因为如果委托父加载器去做，那么对于同一个包，只会有一个版本。

一个简单的思路就是重新调整下loadclass，即对于特定的包，由子类加载器负责，这样就能实现多版本包并存，如下：

```java
@Override
protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
    synchronized (getClassLoadingLock(name)) {
        // First, check if the class has already been loaded
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            if (name.startsWith("java1")) {
                c = findClass(name);
            } else {
                c = getParent().loadClass(name);
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```

**具体场景**

一个很实用的场景就是tomcat的加载过程，几个不同的webapplication，它们的spring版本可能不同，那么就需要分别在自己的子加载器中去加载。对于每个应用程序自己依赖的包，即使用自己的类加载器加载，即从自己的路径下去找，如果是公共的包，即交给父类加载器。

#### 1.2.2 具体加载过程

- 加载

  把字节码（class）文件加载到内存

- 验证

  验证字节码文件是否符合java的规范，这里就要看，是否是在自定义加载器中加载了java开头的包这种安全问题

- 准备

  给类的静态变量分配内存，并赋予默认值，对于基本类型，都会有一个默认值，如果是引用类型，赋值为null

- 解析

  符号引用 -> 直接引用

  这里**符号引用**指的是java中的引用，**直接引用**，即真实地址。

  完成**静态链接**的过程，即类加载期间做完上述过程。

  这里主要针对静态的方法，对于非静态的部分，需要**动态链接**，即程序运行期间执行上述过程。

- 初始化

  类的静态变量赋值，同时执行静态代码块

java程序启动的过程是一个懒加载的过程，对于一个类，只有在用它的时候，才会加载。对于程序员而言，加载一个类的具体启动顺序为：

1. 静态变量

2. 静态代码块

3. 常量

4. 构造代码块

5. 构造方法

## 2. jvm内存模型

java语言天然具有跨平台的特性，不同平台的区别体现在不同的jdk版本上，它们能识别同样的class文件，并转化为对应平台的机器码命令。jvm诞生的时候，正处于c/c++盛行的时代，很自然的它就是在c/c++的基础上诞生的，包括java程序启动，一些类加载器，字节码执行引擎，jvm内存模型中的很多部分都是由c/c++做的。

> jvm组成
>
> - 类装载子系统
>
> - 内存模型
>
>   jvm调优主要是针对这里做的
>
> - 字节码执行引擎

下面着重介绍jvm内存模型

### 2.1 jvm内存模型组成

内存模型由jvm栈、程序计数器、本地方法栈、堆、方法区五部分构成，其中前三部分是每个线程独有，即开启一个线程，就会单独分配这三部分空间，后两部分是线程共享的。

- jvm栈

  **线程独有**

  给线程分配的内存空间，用于存放线程内部的局部变量，保证了线程安全

  每个线程的栈是由一个个栈帧构成，每个栈帧对应一个方法，只有最上层的栈帧是激活状态，这里用栈描述了方法的调用关系，这个栈的容量是有限制的，所以不可能无限的调用，每个栈帧包含了如下信息：

  - 局部变量表 

    基本类型的值、指向堆中的地址

  - 操作数栈

    是一块中转存放的内存空间，执行具体操作的值，包括操作类型，操作的值是从局部变量表中取的

  - 动态链接 

    指向运行时常量（方法区）的地址

  - 返回地址

    指向调用该方法的栈帧地址 

- 本地方法区

  **线程独有**

  如果调用本地方法，即C++方法，会放在本地方法区，java最早诞生的时候，这种场景会比较多，原有的c++/c程序要向java过渡，在过渡的中间状态，免不了会有java调用c++/c程序的场景，这里更具体的是调用对应的dll动态链接库，在jdk的代码中还会有很多这种场景。

- 程序计数器

  **线程独有**

  表示当前线程的执行位置，用户线程切换的时候重新进行定位

- 堆

  存放对象的具体内容，其他地方，例如局部变量表、方法区中存放的都是地址，最终指向堆中，因而，堆是jvm内存模型中占用空间最大，且变化较为频繁的区域。

  根据对象的存活时间，分为年轻代、老年代俩部分：

  - 年轻代

    包括eden（意为伊甸园，即对象出生的地方） s0 s1三部分区域，一般比例是8:1:1，这里区域划分是为了方便之后的垃圾回收。

  - 老年代

    一般占2/3的空间，一般而言，存活较久的对象会被放到老年代中。

  对象会有一个比较重要的属性，年龄，经过一次gc存活下来，年龄加一，一般到15之后，即被放到老年代，证明不会轻易被回收。这里取15是因为存放age的地方在对象头中，而对象头中只为age分配了4位的空间，所以age最大是15。

- 方法区

  包含加载的类、方法、常量、静态变量，是多个线程之间共享的。

  这个是1.8之后做了一定的改动，是直接用的物理内存，如果不设置，默认初始值是21M，之后根据具体使用情况进行缩小或者扩张。每次缩小或者扩张，都是在full gc之后做的，而full gc是比较耗费时间的，故对于规模较大的程序，如果没有设置方法区初始大小，启动过程中，会频繁因为方法区不够而触发full gc，拖慢启动速度。

### 2.2 jvm启动参数

这里列举了常用的针对jvm内存模型大小设置的启动参数：

- 堆

  - Xms 堆大小的最小值

  - Xmx 堆大小的最大值

  - Xmn 年轻代大小

    一般这里Xms和Xmx设置成一样的值，一次分配到位，防止因为堆空间不足触发gc，拖慢系统运行。

  - Xss 线程栈大小

    这里是启动一个线程，jvm给它分配的内存大小，一般而言，对于io密集型程序，可以稍微小一些，对于运算密集型程序可以稍微大一些。

  - XX:MetaspaceSize 方法区触发fullgc的初始值

  - XX:MaxMetaspaceSize 方法区最大大小

    同堆大小设置，这里一般也会设置成相同的配置，视程序大小来设置，**一定要有**，否则就会采用默认初始值，拖慢系统启动速度，具体解释见2.1方法区介绍。

### 2.3 jvm gc初探

这里大体讲下gc的概念，语义上是垃圾回收，即空间不够用的时候，做的一步就是回收不会再被使用的对象。对于gc，有两个重要的概念，**gc root**、**stw**，前者是gc过程中进行对象引用标记的起点，由gc root开始，把被引用到的对象标记出来，意思是它们目前还在使用，不要回收，剩余的对象没有引用，则可以被当成垃圾回收。同时，由gc root开始做对象引用标记的过程中，需要所有的用户线程停止一切动作，否则会导致标记结果不准确，在这个过程中对于jvm中的用户线程而言，世界都停止了，所以这个过程被称为stop the world，即stw。stw因为设计所有用户线程的停止运行，故会影响java程序的流畅性。

gc分类：

- young gc

  针对年轻代的gc，前面讲解年轻代的空间的时候，提到年轻代有eden、s0、s1三部分构成，所有对象都是构建在eden中的，如果eden中的空间不够用了，即触发young gc，期间会stw，并找到还有被引用的对象，存放到s0中，之后清空eden以及s1中的对象，之后程序继续运行，直到eden空间又不够了，同样会stw，找到还有被引用的对象，放到干净的s1中（因为s1已经在上一轮gc中被清空）。。。。

  所以这里s0、s1是交替使用的关系，任意时刻，这两个区域总有一个是干净的，用于存放下一次gc之后还存活的对象。

  对于经过一次gc存活下来的对象，它的**age**会加一，当age足够大，会在适当的时机被放到老年代中，可能是存放存活对象的s区域不够用了或者是其它原因。

- full gc

  如果老年代经过一段时间程序运行，空间也不够了，或者方法区在程序启动过程中，空间不够了，就会触发full gc，相对于young gc，它耗费的时间要大的多，因为这里要扫描所有的对象，而young gc中只会扫描年轻代中的对象，因而full gc中stw时间会久一些。故full gc是要尽量避免的，之后的jvm调优中，一部分内容就是讲怎么避免频繁触发full gc。

讲义中讲了一个例子，说对于一个大促过程中的系统，产生对象的速度要比平时多很多，同时这些对象也会很快变成垃圾对象，这些对象都是在年轻代中生成、存放的，为了避免full gc，即这些垃圾对象在被回收之前进入老年代，可以考虑增加年轻代的空间，尽量让垃圾对象一直在年轻代中，到下次触发young gc的时候直接被回收。

### 3. jvm对象创建

- 类加载检查

- 内存分配

  - 指针碰撞

    针对内存空间是连续分配的情况

  - 空闲列表

    针对内存空间是不连续的情况

  这两种分配方式都会有并发问题，即两个线程竞争分配内存，如果不加以控制，可能会取到相同的空间，为了解决并发问题，有两种方案：

  - cas，保证同时只有一个线程竞争成功
  - tlab，thread local allocation buffer，1.8之后，默认采用这种方式，即在eden中给每个线程分配一块空间，不同线程操作自己分配到的那块，避免冲突，默认分配的空间大小是eden大小的1%，如果放不下，就使用cas的方式去竞争。

- 初始化

- 设置对象头

  堆中对象分配堆空间主要是由 对象头、实例数据、填充部分（保证对象大小是8字节的整数倍，这里是考虑提升运行效率） 构成。对象头记录了一个对象在jvm中通用的一些属性，包括类型指针、age、加锁情况等。
  
  对象头组成：
  
  - mark word
  
    占用大小 32位-4byte 64位-8byte
  
    一般是有锁状态、hashcode、分代年龄、锁标志位这些部分，具体的根据不同的锁状态有不同的结构
  
  - klass pointer
  
    开启压缩 占用4byte，java一般默认开启指针压缩，不开的话，64位系统地址应该是8位，开了之后就是4位。
  
    类型指针，指向方法区的类元数据，即标识该对象的类型，真正使用这些信息的应该是c++代码调用的。
  
    正常我们java代码中使用的Class<?>对象，是给java程序用的，提供到方法区类元数据的指针。
  
  - 数组长度
  
    如果对象是一个数组，则有这部分，占用4个字节。
  
  